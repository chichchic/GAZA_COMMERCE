- Selection Sort
    - 방법: 가장 작은 것을 선택해 가장 앞으로 보낸다.
    - 시간 복잡도: O(n^2)
    - 이점: x
- Bubble Sort
    - 방법:
        - 양 옆의 숫자를 비교해서 작은 값을 앞으로 보냄
        - 가장 큰 값부터 가장 마지막으로 가서 i, i - 1, i - 2 ... 번 수행
    - 시간 복잡도: O(n^2)
    - 이점: 구현이 쉬움
- Insert Sort
    - 방법:
        - 특정한 원소의 앞의 원소들을 보면서 어디에 들어갈 지 적절한 위치를 찾아 삽입한다.
        - 위치변경이 반드시 일어나지 않는다.
    - 시간 복잡도: O(n^2)
    - 이점: 거의 정렬되어있을 때 빠름
- Merge Sort
    - 방법:
        - 분할 정복 알고리즘을 사용함
        - 전부 쪼개져 있는 상태에서 2의 배수만큼 합친다.
    - 시간 복잡도: O(nlogn)
    - 이점:
        - 어떤 상황에서도 O(nlogn)이 보장됨
        - 메모리가 조금 낭비됨
- Quick Sort
    - 방법:
        - 분할 정복 알고리즘을 사용함
        - 특정한 Pivot 값을 기준으로 큰 값과 작은 값을 기준으로 나눔 (일반적으로 Pivot은 가장 앞)
    - 시간 복잡도:
        - 평균: O(nlogn)
        - 최악: O(n^2) (이미 정렬되어 있는 경우)
    - 이점: 빠름
- Heap Sort
    - 방법: Heap구조를 이용해서 정렬
    - 시간 복잡도: O(nlogn)
    - 이점:
- Tim Sort
    - merge sort와 insert sort가 섞여서 있는 불안정 정렬이다.
    - O(nlogn)의 시간을 보장한다.
