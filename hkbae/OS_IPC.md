# IPC (Inter-Process Communication)

* 프로세스는 **개별적인 메모리 주소 공간을 갖게 됩니다**. 시스템 내의 프로세스들은 독립적으로 수행될 수 도, 서로 간의 협력을 통해 수행되어야 할 수 도 있습니다.
* 이러한 독립적인 구조로 하나의 프로세스에 문제가 생겼을 때 다른 프로세스에 영향을 끼치지 않는다는 장점을 갖고 있지만 프로세스간의 통신(IPC)이 복잡하다는 것이 단점입니다.

* 프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간 통신을 할 수 있게 됩니다.
* 이러한 IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해 세마포어와 뮤텍스를 사용합니다.
  * 공유된 자원에 한번에 하나의 프로세스만 접근 시키도록.



## IPC 종류

### 공유 메모리

<img width="336" alt="ipc-1" src="https://user-images.githubusercontent.com/68215452/137626013-18a6a831-72db-4190-ba83-5b4bb7228324.png">

*  **공유 메모리는 데이터 자체를 공유하도록 지원하는 방법**입니다.
* 프로세스의 메모리 영역은 독립적으로 가지며 다른 프로세스가 접근 못하도록 반드시 보호되어야 합니다. 이러한 메모리 영역을 스레드처럼 공유하도록 해주는 것이 그 아이디어입니다.
* 프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해주고 이후 모든 프로세스는 해당 메모리 영역에 접근할 수 있게 됩니다.
  * 할당 이후 O.S가 아닌 사용자 프로세스의 통제하에 있게 됩니다.
  * **중개자 없이 곧바로 메모리에 접근할 수 있어서 IPC중에 가장 빠르게 동작합니다.**
* 주요 이슈는 **유저 프로세스가 공유 메모리에 액세스할 때 작업을 동기화할 수 있는 메커니즘을 제공**하는 것입니다.

### Message Passing

<img width="335" alt="ipc-2" src="https://user-images.githubusercontent.com/68215452/137626017-124cfcb1-f1dc-41a5-9c07-7d56e3c016a4.png">

* OS가 제공하는 IPC 설비를 통해 이루어지는 프로세스간 통신 기법입니다. 즉 Shared Memory와 다르게 메모리 보호를 위해 커널이 대신 전달해주게 됩니다.

  * `send(message)` 를 통해 커널에 보내주면 커널이 이 메세지를` receive(message)` 를 호출한 프로세스에게 보내주게 된다.

  * 이 메세지의 크기는 고정될 수도 있고 가변적일 수도 있습니다.

    * 고정 -> 시스템 레벨에서 간단하지만 프로그램 실행시 어려워진다.
    * 가변 -> 시스템 레벨에서는 복잡하지만 프로그램 실행 면에서는 간단해진다.

    

* 입출력 방식은 Named 파이프와 동일합니다. 다른점은 메세지 큐는 파이프처럼 데이터의 흐름이 아니라 메모리 공간입니다.

* 사용할 데이터에 번호를 붙이면서 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있습니다.

* Message Passing에서는 Producer와 Consumer의 개념이 희미해집니다. 그저 send함수와 receive함수를 호출하여 메세지 큐에 메세지를 보내고 받아올 뿐입니다.



### Signals

* 특정 이벤트를 프로세스에게 알리는 IPC의 메커니즘 입니다. 이는 동기적으로(ex. 잘못된 메모리 접근), 비동기적으로(ex. 중단) 발생할 수 있습니다. 
* **소프트웨어 인터럽트**로 생각할 수 있습니다. Signal은 특정 이벤트에 의해 생성이 되어 프로세스에게 전달됩니다. 이때 `signal handler` 가 signal을 처리하게 됩니다. 모든 signal은 신호 처리 시 커널모드가 실행되는 기본 핸들러가 존재합니다. 사용자 정의 signal handler로 재정의할 수 도 있습니다. 
* 프로세스는 signal을 다른 프로세스에게 보낼 수 있습니다. ( `int kill(pid_t pid, int sig)`)
* signal의 다양한 신호들은 `man 7 signal` 을 통해 확인할 수 있다.



### Remote Procedure Calls (RPCs)

<img width="908" alt="ipc-3" src="https://user-images.githubusercontent.com/68215452/137626018-86d15e85-05f1-4b01-a84c-33b9efc9578d.png">

* 네트워크 상의 원격 프로세스에 접근하여 프로시저 또는 함수를 호출하여 사용할 수 있는 방법입니다.
* `Stub` 은 서버 측의 실제 프로시저를 추상화하는 프록시 객체입니다.
  * 클라이언트 측의 스텁은 서버를 찾고 매개 변수를 **마샬링**합니다. (네트워크로 전송할 수 있는 형태로 포장)
  * 서버측 스텁(a.k.a **Skeleton**)은 이 메세지를 수신하고 마샬링된 메세지를 해제하고 서버 측에서 프로시저를 수행합니다.

* RPC는 클라이언트와 서버 구조를 기반으로 작동하며 각각의 클라이언트와 서버는 리모트 콜을 하기 위한 메서드의 인터페이스를 통해 서로의 요청에 대해 이해할 수 있다.



**RPCs 과정**

1) IDL(Inerface Definition Language)를 사용하여 서버의 호출 규약을 정의합니다.
   * 함수명, 인자, 반환값에 대한 데이터 형이 정의된 IDL 파일을 rpcgen 컴파일러를 이용하여 stub 코드를 자동으로 생성합니다.
2) Stub은 원시 소스코드 (C코드 등) 형태로 만들어지므로 클라이언트, 서버 프로그램에 포함하여 빌드 합니다.
3) 클라이언트 프로그램 입장에서 자신의 프로세스 주소 공간의 함수를 호출하면 stub에 정의된 함수를 호출할 수 있게 됩니다.
4) stub 코드를 **XDR(eXternaml Data Representation)** 형식으로 변환하여 RPC 호출을 실행합니다.
   * XDR 변환 이유는 기본 데이터 타입에 대한 메모리 저장 방식(빅 엔디안, 리틀 엔디안)이 아키텍처마다 다르며 네트워크 전송 과정에서 바이트 전송 순서를 보장하기 위함입니다. 
5) 서버는 수신된 함수/프로시저 호출에 대한 처리 완료 후, 결과 값을 XDR로 변환합니다.
6) 최종적으로 클라이언트 프로그램은 서버의 결과값을 반환합니다.



**XDR**

* 다른 아키텍처에서 서로 다른 데이터 표현 방식을 다루기 위한 형식입니다. 

  ex)`0A0B0C0D` 을 다르게 표현

  * 빅 엔디안  [0A,0B,0C,0D]
  * 리틀 엔디안 [0D,0C,0B,0A]

* 각 로컬 환경에서 로컬에서 사용하는 표현을 XDR로 만드는 과정을 **marshalling**, 그 반대의 과정을 **demarshaling** 이라고 한다.

### PIPE

* 파이프는 두 프로세스가 통신할 수 있는 통로입니다. 초기 UNIX 시스템에서 최소의 IPC 메커니즘 중 하나입니다.
* Ordinay Pipe vs Named Pipe
* 단방향 통신? 양방향 통신?
* 양방향 통신의 경우 half-duplex? full-duplex
* 파이프가 네이트워크를 통해 사용될 수 있는가?

**Ordirnary PIPE**

<img width="642" alt="스크린샷 2021-10-17 오후 8 50 26" src="https://user-images.githubusercontent.com/68215452/137626097-4bad6d98-e00b-4b53-989b-229b14ff92b5.png">

* 전형적인 Producer-Consumer 컨셉의 파이프 방식입니다. 생산자는 파이프의 write-end에서 데이터를 쓸 수 있고 Consumer는 read-end에서 데이털르 읽을 수 있습니다.
  * 당연하게도 단방향 통신입니다. (반 이중 통신)
  * 두 개의 프로세스 사이에 부모-자식 프로세스 간의 관계를 필요로 합니다.
* 양쪽으로 모두 송/수신을 하고 싶으면 2개의 파이프를 만들어야 합니다.
* 매우 간단하게 사용할 수 있는 장점이 있고, 단순한 데이터 흐름을 가질 땐 파이프를 사용하는 것이 효율적입니다.
* 단점으로는 전 이중 통신을 위해 2개를 만들어야 할 때는 구현이 복잡해지게 됩니다.



**Named PIPE**

* 익명파이프는 부모-자식 프로세스간 통신처럼 통신할 프로세스를 명확하게 알 수 없을 때 사용합니다.
* Named 파이프는 전혀 모르는 상태의 프로세스들 사이 통신에 사용됩니다.
* 즉 익명 파이프의 확장된 상태로 부모 프로세스와 무관한 다른 프로세스도 통신이 가능합니다.
  * 이들은 통신을 위해 이름 있는 파일을 사용하게 됩니다.
* 양방향 통신을 지원합니다. 
* 하지만 Named 파이프 역시 읽기/쓰기 동시에 불가능합니다. 따라서 전이중 통신을 위해서 익명 파이프처럼 2개를 만들어야 합니다.



### 메모리 맵

* 공유 메모리처럼 메모리를 공유하는 방식입니다. **메모리 맵은 열린 파일을 메모리에 맵핑시켜서 공유하는 방식**입니다. 
  * 즉 공유 매개체가 파일 + 메모리 입니다.
* 주로 파일로 대용량 데이터를 공유해야 할 때 사용합니다.



## 참고자료

* https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/IPC(Inter%20Process%20Communication).md
* https://leejonggun.tistory.com/9

