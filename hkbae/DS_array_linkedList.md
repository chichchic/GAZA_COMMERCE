## 1. Array , Linked List

### Array

타입이 같은 데이터들을 하나로 묶어주는 자료구조로 논리적인 저장 순서와 물리적인 메모리의 저장 순서가 같다는 특징이 있습니다. 따라서 인덱스로 상수시간의 시간복잡도로 데이터에 접근이 가능합니다.

- 가장 기본적인 자료구조로 **논리적인 저장 순서와 물리적인 저장 순서가 일치**한다.
- 타입이 같은 데이터들을 하나로 묶는 방법

+장점

- 인덱스(index)로 해당 원소에 접근할 수 있다.
    - O(1)의 시간 복잡도
    - 즉 random access가 가능하다.
        - 비 순차적인 접근.
        - 축적된 기억을 임의의 순서로 이용할 수 있는 방식

 - 단점

- 삽입,삭제 과정에서 해당 원소에 접근하여 작업을 완료한 후 추가적인 작업이 필요하다.
- 삭제한 원소보다 큰 인덱스를 갖는 원소들을 왼쪽으로 shift 해줘야하는 비용
- 새로운 원소보다 크거나 같은 인덱스를 갖는 원소들을 오른쪽으로 shift 해줘야하는 비용
- **O(n)의 시간복잡도**

### Linked List

연결리스트는 각 항목들을 데이터와 링크의 쌍인 노드에 분산 저장하는 자료구조입니다. Array와는 다르게 메모리 내 노드의 물리적인 순서가 논리적 순서와 일치할 필요가 없습니다. 이에 따라서 검색 시간은 O(n)의 시간복잡도 갖게 되지만 삽입,삭제 시에는 노드의 링크만 변경해주면 되기 때문에 상수시간의 시간복잡도를 갖습니다.

- 리스트의 항목들을 **노드(node)**라는 곳에 분산 저장
    - **필요할 때 마다 동적 메모리 생성**
- 노드 = <데이터, 링크> 쌍
- 메모리 내 노드의 물리적 순서가 리스트의 논리적 순서와 일치할 필요가 없다.

 + 장점

- **삽입과 삭제**를 **O(1)**만에 해결할 수 있다.
- 모든 원소들이 자기 자신 다음에 어떤 원소인지 만을 기억하고 있다.
- 따라서 이부분만 다른 값으로 바꿔주면 된다.

 - 단점

- Array와 다르게 논리적 저장 순서와 물리적 저장 순서가 일치하지 않는다.
- 어떠한 원소를 조회하는데 **O(n)의 시간복잡도**
- 생각해보면 어떠한 위치에 원소를 추가하고자 한다면 해당 위치를 우선적으로 탐색해야 한다. 결국 이는 삽입,삭제에 대해서도 그 원소를 찾기 위해서 O(n)의 시간을 추가적으로  갖는다고 할 수 있다.
- 이 Linked List는 Tree 구조의 근간이 되는 자료구조이며 Tree에서 사용되었을 때 그 유용성이 드러난다.
