# System Call

## Overview

* Application이 시스템에 손상주는 것을 막기 위해 CPU는 `유저모드`와 `커널모드`가 존재합니다.

  * ex. 디스크에 직접적인 접근을 막기 위해, 인터럽트 핸들러의 오버라이딩을 막기 위해, HLT 명령어(프로그램 종료)의 사용을 막기 위해

* `유저모드` 와 `커널모드`를 구분함으로 운영체제는 자기 자신으로부터 그리고 다른 시스템 요소로부터 안전하게 보호될 수 있습니다. 이러한 모드는 `Mode bit` 를 통해 구분됩니다. (0: 커널모드, 1: 유저모드) HLT와 같은 `privilleged instruction`  들은 커널모드에서만 동작됩니다.

* `Privilleged Instructions` 은 다음과 같은 명령들이 포함됩니다.

  * I/O에 직접적인 접근, 시스템 레지스터의 접근 또는 조작, 메모리 상태 관리, HLT 명령
  * 유저모드에서 이 명령들을 실행하면 **exception**이 발생합니다.

* **Exception**

  * `Exception`은 소프트웨어 명령에 의해 발생됩니다. (0으로 나누거나, 권한이 허용되지 않는 데이터의 접근 등)

  * 따라서 `Exception` 은 CPU가 명령들을 실행했을 때 **동기적**으로 발생합니다. 

  * 더 세부적으로 나누어서 **Trap** 과 **fault** 로 구분할 수 있습니다. `Trap`은 예상되는 exception이고 `fault` 는 예기치 못한 상황에서의 exception 입니다.

  * c.f) 한편 `Interrupt` 는 하드웨어에 의해 비동기적으로 발생합니다.

    

* 유저모드에서 커널모드로의 전환은 **인터럽트** 에 의해 비동기적으로 발생할 수 있습니다.  예를들면 타이머를 통해 일정 기간동안 인터럽트를 발생시킬 수 있도록 설정합니다. 그리고 이 인터럽트가 발생하면 유저모드에서 커널모드로 전환하고 OS는 다음 실행시킬 프로세스를 결정(스케줄링)할 수 있습니다.

  

* 또한 **system call** 에 의해 동기적으로 발생할 수 있습니다. 유저모드에서 프로그램을 실행하던 중 privilleged instruction을 사용할 필요가 있다면 system call을 호출합니다. 이에 따라 trap이 발생하게 되고 mode bit는 0에서 1로 변환됩니다. 커널모드에서 시스템 콜을 수행하고 완료되면 다시 mode bit를 1로 변경하여 유저모드로 돌아옵니다. 

* 즉 시스템 콜은 high-level language로 제공되는 API를 통해 커널모드로 접근하여 명령들을 수행할 수 있게 해주는 인터페이스 입니다. 시스템 콜은 프로그램의 실행, I/O 작업 수행, 파일 시스템 조작, 통신, 에러 감지, 자원 할당, 프로세스 제어 등이 포함됩니다. 



* fork(), exec(), wait() 와 같은 것들은 프로세스 생성과 제어를 위한 시스템 콜입니다.
* fork()와 exec()은 새로운 프로세스 생성과 관련이 되어 있습니다.
* wait()은 부모 프로세스가 만든 다른 자식 프로세스가 끝날 때 까지 기다리게 되는 명령어입니다.



## Fork

<img width="725" alt="그림1" src="https://user-images.githubusercontent.com/68215452/137626003-f89a17b9-2bef-411d-a5f8-4451909b0db4.png">

* fork()는  현재 프로세스를 **복제**하여 새로운 **프로세스를 생성**합니다. 부모 프로세스는 자신의 대부분의 리소스와 권한들을 상속합니다(Open files, UID, etc). fork()로 생성된 자식 프로세스는 부모의 PCB를 대부분 복제합니다.
* 결국 쉘이나 GUI에서 fork()를 내부적으로 생성하여 프로세스를 생성하는 것입니다. fork() 성공 시에는 자식 프로세스의 PID를 반환하고 자식 프로세스의 경우에는 0을 반환합니다. 실패 시에는 부모 프로세스가 -1을 반환하고 자식 프로세스는 생성되지 않습니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *agrv[]){
  printf("pid : %d",(int)getpid()); // pid : 29146
  
  int rc = fork(); // pid : 29147
  
  // (1) fork 실패
  if (rc < 0){
    exit(1);
  // (2) child 프로세스의 경우 fork는 0이다.
  }else if (rc == 0){
    printf("child (pid : %d)", (int)getpid());
  // (3) 부모 프로세스의 경우 
  }else{
    printf("parent of %d(pid : %d)",rc,(int)getpid());
  }
}
```



* 위 프로그램을 실행하면 다음과 같이 실행됩니다.

  pid : 29146

  parent of 29147(pid : 29146)

  child (pid : 29147)

* 다만 부모 프로세스와 자식 프로세스간의 순서가 항상 일정하지 않습니다. 개발자는 이를 확신할 수 없고 이는 O.S의 스케줄러가 결정하는 것입니다. 

* fork()가 실행되는 순간 자식프로세스가 생성되는데 이는 부모 프로세스와 거의 동일한 복사본을 갖게 됩니다. 이때 OS는 위와 똑같은 2개의 프로그램이 동작한다고 생각하고, fork()가 return될 차례라고 생각합니다.  그 때문에 자식 프로세스는 main에서 시작하지 않고 if문부터 시작하게 됩니다.

* 부모 프로세스와 자식 프로세스의 차이점이 존재하기는 합니다. 바로 fork()의 값이 다르다는 점입니다. 따라서 완전한 동일한 복사본이라고 할 수는 없습니다.

  * 부모의 fork() 값은 자식 프로세스의 pid 값이 되고 자식 프로세스의 fork() 값은 0이 됩니다.
  * 이렇게 fork() 값이 다르다는 점은 매우 유용한 방식입니다. 그러나 스케줄러가 부모를 먼저 수행할지 아닐지는 확신할 수가 없습니다.



## exec()

<img width="300" alt="그림2" src="https://user-images.githubusercontent.com/68215452/137626007-f310f85e-030d-4c09-9547-f9282118e099.png"> <img width="300" alt="그림3" src="https://user-images.githubusercontent.com/68215452/137626012-8c551213-d514-47f4-aad1-0efd2b51238d.png">


* exec()은 현재 프로세스의 이미지를 새로운 프로세스의 이미지로 **대체**하는 것입니다. **현재 주소 공간의 내용들이 버려지고 새로운 주소공간을 갖게** 됩니다. 
*  fork와 다른 점은 생성되는 새로운 프로세스는 없고, exec()을 호출한 프로세스의 PID가 그대로 새운 프로세스에 적용이 되며, exec()을 호출한 프로세스는 새로운 프로세스에 의해 덮여 쓰여지게 됩니다.
* 이 점을 이용하면 fork()와 exec() 의 조합으로 프로세스를 새롭게 생성할 수 있습니다. 
* exec()을 사용하는 목적은 **프로세스의 구조체를 재활용**하기 위함입니다. 새로운 프로세르르 만드려면 PCB를 만들고 메모리의 자리를 확보하는 과정이 필요한데 exec()을 활용하면 이미 만들어진 PCB, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있어 편리합니다. 

