**용어 정리**
프로그램: 어떤 작업을 위해 운영체제 위에서 실행할 수 있는 파일
프로세스: 운영체제 위에서 실행중인 프로그램. 프로세스 안에 있는 스레드가 실행중이면 프로세스가 동작하고 있다고 말한다.
프로세서: 프로세스가 동작될 수 있도록 하는 하드웨어(=CPU)

### 레지스터
CPU가 요청을 처리하는데 필요한 데이터를 일시적으로 저장하는 장치.
메모리로 연산의 결과를 보내거나 영구적으로 저장할 데이터를 하드디스크에 저장하는 등의 멸령을 처리하기 위해
이들에 대한 주소와 명령의 종류를 저장하는 공간.
메모리보다 빠르다.
CPU는 자체적으로 데이터를 저장할 수 있는 방법이 없기 때문에 메모리로 직접 데이터를 전송할 수 없어 반드시 레지스터를 거쳐야한다.
32bit/64bit가 의미하는 바가 하나의 레지스터가 저장 가능한 공간의 크기를 의미한다.
CPU당 한개만 존재하는것이 아니며, 필요와 용도에 따라 여러 종류가 있다.

# 운영체제란
하드웨어가 소프트웨어와 통신하고 작동하도록 하는 프로그램
**목적**
컴퓨터 시스템을 제대로 동작하게 한다.
프로그램 개발 및 실행을 위한 환경을 제공한다.

# 프로세스
컴퓨터에서 실행되고 있는 프로그램(메모리에 적재되어 CPU의 할당을 받음)
한 개 이상의 메인 쓰레드를 가진다.
각 프로세스는 다른 프로세스에 접근할 수 없다.
다른 프로세스의 자원에 접근하려면 Inter-Process Communication을 사용해야한다.(파일, 소켓, 파이프 등)
코드, 데이터, 힙, 스택 영역으로 나누어 메모리에 적제된다.

**상태**
Create: 생성
Ready: 할당을 대기하거나, 작업이 끝난 상태
Run: 스케줄러에 의해 작업이 할당된 경우
Waiting: 프로세스가 I/O로 인해 CPU 할당을 받지 못할 때, I/O작업이 끝나면 다시 ready 상태로 돌아가야 한다.
Terminated: 프로세스가 종료됨

**PCB**
프로세스에 대한 정보는 Process Control Block에 저장되어 있다.
어떤 프로세스가 어디까지 진행되었는지에 대한 정보이다.
1. PID: 프로세스 식별자
2. State: 프로세스 상태
3. Program Counter: 프로세스가 다음에 실행할 명령어의 주소
4. CPU 스케줄링 정보: 우선순위, 최종 실행 시각, CPU 점유시간 등
5. 사용중인 레지스터 정보
6. 메모리 관리 정보: 사용 가능한 메모리 공간 정보
7. 입출력 상태 정보: 프로세스에 할당된 입출력 장치 목록, 사용 파일 목록 등
8. pointer: 부모 프로세스에 대한 포인터, 자식 프로세스에 대한 포인터, 프로세스가 위치한 메모리 주소에 대한 포인터, 할당된 자원에 대한 포인터.

**TCB**
여러개의 스레드가 존재하는 프로세스에서 context switching이 일어날 때 사용하는 정보
스레드별로 존재하며, PC, 사용중인 레지스터 정보, PCB를 가르키는 pointer를 가지고 있다.

## 프로세스 메모리
- Stack
지역 변수, 매개 변수, 함수 호출 정보 등이 저장된다.
크기가 고정되어있어 너무 큰 변수가 들어올 경우 stack overflow가 발생한다.
- Heap
메모리 주소에 의해 참조될 수 있는 영역
런타임에 동적으로 크기가 결정된다.(컴파일시에는 크기를 알 수 없는 데이터들이 여기에서 공간을 할당받는다.)
메모리를 할당해 줄 때 메모리(chunk)에 대한 정보들이 함께 들어오는데 prev_size, size, fd, bk, fd_nextsize, bk_nextsize가 있다.
- Data
전역 변수, 정적 변수가 저장된다.
- Code
프로그램 명령어가 저장되는 공간.

CPU와 RAM에 적재되면서 Cache에도 들어간다.
PCB는 적재될 때 RAM에 적재되어 register 값이 CPU코어에 있는 값에 올라간다.
PCB에 있던 레지스터 블록들이 코어에 들어간다.

# 쓰레드
한 프로세스의 실행 단위(프로세스가 할당받은 자원을 이용하는 실행 단위)
같은 프로세스 내 쓰레드는 Code, Data, Heap영역을 공유한다.
ID, Program Counter, Register, Stack으로 구성된다.
프로세스와 마찬가지로 Context Switching이 발생하지만, 공유 메모리로 인해 오버헤드가 적다.

thread에서 context switching을 할 때 저장해야할 정보: Program Counter(어디까지 실행되었는지 레지스터에 독립적으로 저장된다.)
Register를 독립적으로 가지는 이유:
쓰레드는 CPU를 할당 받았다가 스케줄러에 의해 다시 선점당한다. 따라서 명령어가 연속적으로 수행되지 못하게 될 수 있어 어디까지 수행되었는지 기억할 필요가 있따.

## 커널 스레드 vs 사용자 스레드
커널 스레드: 커널 모드에서 실행되는 스레드
사용자 스레드: 사용자 모드에서 실행되는 스레드

**Context Switching**
CPU는 한번에 하나의 프로세스만 계산할 수 있다.
CPU가 실행하는 프로세스가 교체될 때 CPU에서 관리하는 context가 교체되는 것
인터럽트가 발생할 경우, 프로세스를 종료하고 다음 프로세스를 수행한다.
이때 종료될 프로세스의 context를 PCB에 업데이트하고, 실행 할 다음 프로세스의 context를 메모리에 올려서 CPU가 실행할 수 있도록 해준다.
하지만, Context Switching일 때 해당 CPU는 아무일을 할 수 없어서 오버헤드가 발생한다.
인터럽트 종류:
1. 입출력 요청
2. cpu사용 시간 만료
3. 자식 프로세스 생성
4. 인터럽트 처리 대기

## 멀티 프로세스 vs 멀티 쓰레드
멀티 프로세스
- 부모 프로세스에서 자식 프로세스로 fork()
- 각 프로세스는 독립적
- 자원 소모적, 개별 메모리 차지
- InterProcessCommunication으로 통신
- Context Switching 할 때 비용이 크다.
- 동기화 작업이 필요하지 않다.

멀티 쓰레드
- Thread끼리 긴밀하게 연결되어있음(공유 자원)
- 공유 자원(code, data, heap 영역) 을 통해 통신하여 비용이 절감된다.
- 공유 자원으로 인해 메모리 효율을 높힌다.
- Context Switching 비용이 적다.
- 공유 자원을 관리해야한다.(동기화)

멀티 프로세스를 사용하는 이유: 멀티 쓰레드를 사용할 경우 한 쓰레드에 문제가 생길 경우 전체 프로세스에 영향이 간다. 하지만 멀티 프로세스는 그에 비해 영향을 덜 받는다.

### 멀티 코어와 멀티 스레딩
멀티 코어: 2개 이상의 processor를 포함한 직접회로를 뜻한다.
동시성(Concurrency): 빠른 텀으로 context switching -> 동시에 진행되는것처럼 보임
병렬처리(parallelism): 두개의 코어에서 한꺼번에 병렬처리가 일어나 한꺼번에 진행 됨. 멀티 코어

멀티 스레딩: 하나의 프로세스에 다수의 스레드를 실행시키는 상태
스레드는 프로세스에 비해 문맥 교환 시간이 짧고 스레드간 통신 방법이 간단하다.
스레드간 공유하는 자원으로 인해 동기화 문제가 발생할 수 있다.

멀티 코어의 환경에서는 멀티 스레딩이 발생 할 경우 code data heap영역을 L2 cache를 통해서 공유하게 된다.
하지만 멀티 코어임에도 멀티 스레딩을 지원하지 않는 프로그램을 짤 경우 한개의 코어만 돌게된다.(비 효율적)

### 멀티 스레드 vs 멀티 프로세스
멀티 스레드: 스레드를 활용하기 때문에 메모리 공간을 적게 활용하고, 문맥 교환 시간이 짧다. 하지만 동기화 문제가 발생할 수 있다.
멀티 프로세스: 하나의 프로세스에 문제가 발생해도 다른 프로세스에 영향을 주지 않는다. 하지만 멀티 스레드에 비해 메모리 공간과 CPU시간을 더 차지한다.

### 멀티 프로그래밍
단일 프로세서에서 CPU작업과 I/O작업을 병행하는 상태
실행중이 프로세스에서 I/O 작업으로 인해 CPU가 유휴상태가 되면 CPU 작업이 필요한 다른 프로세스를 실행시킨다.
CPU의 이용과 처리량을 증가시킬수 있다.

**프로세서, 코어, 쓰레드**
프로세서:
컴퓨터 운영을 위해 기본적인 명령어들을 처리하고 반응하기 위한 논리회로.
Control Unit과 ALU로 구성된다. CPU를 보조하며 연산, 제어하는 부분이나 점차 CPU와 유사하게 사용된다.
코어:
하드웨어 단에서의 물리적 구성단위중 하나로 CPU안에 일하는 부품 중 하나.
CPU내 코어 이외에 컨트롤러, 캐시 메모리 등이 존재하나, 코어가 하는 역할은 프로세서가 하는 일을 분담하는데 있다.
따라서, 멀티 프로세서와 멀티 코어는 다르다.
쓰레드:
소프트웨어 관점에서의 논리적 작업 처리의 단위. 데이터의 실행 흐름으로 데이터가 지나다니는 통로로 생각하면 된다.(코어가 일을 수행할 때 팔과 다리의 역할)

# 스케줄링
다음으로 실행할 프로세스를 선택하는 역할을 한다.
**평가기준**
CPU 이용율: CPU 사용 비율
처리율: 시간당 처리한 프로세스 수
반환 시간: 프로세스 첫 작업 시간부터 종료하는데 걸린 시간
대기 시간: CPU 점유를 위해 대기한 시간
응답 시간: 프로세스 작업 요청 후 응답을 대기하는 시간

## SJF
과거의 기록을 통해 predict한 후 짧은 시간을 소모할것같은 프로세스에 자원을 할당해 줌.
선점형: 현재 실행중인 프로세스보다 짧은 프로세스가 들어올 경우 바로 교체하는 방식
비선점형: 현재 실행중인 프로세스는 무조건 끝까지 실행시키는 방식

## Round Robin
선점형 FCFS(first come first served)면서 할당된 시간만큼만 실행하고 교체하는 방식.
만약 할당 시간보다 짧을경우 먼저 자발적으로 빠져나올 수 있다.
할당시간이 너무 짧으면 context switching이 너무 자주 일어나서 overhead가 발생한다.

## priority base
사실 SJF또한 priority base의 일종이다.
따로 priority를 설정해주는걸 통해서 먼저 실행 될 process를 결정한다.
선점형, 비선점형 둘 중 어떤것으로 할지에 따라 다른다.

priority base의 경우 starvation이 발생할 수 있다.(priority가 낮을 경우 오랫동안 실행되지 않을 수 있다.)
해결 방법: 시간이 지날수록 priority를 높여준다.(aging)

multi-level queue: 우선순위에 따라서 queue를 여러개 만들어 해당 높은 priority queue에 있는 process를 먼저 실행시키는 방법
이때도 stavation이 발생할 수 있는데 queue에 따라 스케줄링 방법을 다르게 해주어 해결할 수 있다.(높을 수록 짧은 할당 시간을 가진 RR방식으로 하는 등)

# 동기화 문제
일의 순서에 맞게 데이터를 사용할 수 있도록 보장해줘야하는 문제
concurrent, parallel 둘다 발생할 수 있음

# 동시성 문제
두 개 이상의 스레드를 사용하면서 동일한 메모리 접근등으로 인해 발생할 수 있는 문제

## 경쟁 상태
예측 가능한 operation sequence의 completion순서가 예상치 못하게 흘러가 프로그램의 로직이 undefined state가 되는 경우를 말한다.
데이터 불일치를 야기할 수 있다.(누가 먼저 접근했느냐에 따라 다른 결과값을 반환하는것)
계좌 이체같은 경우에 발생할수 있는데 굉장히 critical한 문제를 야기할 수 있다.
이러한 문제가 발생할 수 있는 code 영역을 critical section(임계 영역)이라고 부르는데, 여기서 동시에 접근이 불가능하게 함으로 해결이 가능하다.

**해결을 위해 필요한 조건**
1. Mutual Exclusion(상호배제, 필수)
상호 배제를 할수 있도록 해야한다.
하지만 이 경우, starvation문제와 deadlock(교착상태)이 발생한다.
2. Progress(진행)
dead lock을 피하는 방식
한 process가 critical section에 들어갔을 경우 다음 process는 critical section에 들어가는것을 연기하는 방법으로 해결
3. bounded waiting(유한 대기)
starvation을 피하는 방식
기다리는 시간을 제한적으로 만들어 해결

**발생하는 경우**
여러 스레드 or 프로세스가 한정된 공유자원에 동시에 접근하는 경우(parallel)
공유 자원을 번갈아 프로세스가 write하는 경우(concurrent)

경쟁상황을 해결하기 위해서 synchronized 해줘야 한다.

**해결방법**
해결 과정에서중 flag를 확인하는 과정의 교체 경우에 원자성을 보장할 수 있어야한다. (context switching이 발생할경우 원하는대로 이루어지지 않을 가능성 있음)
원자성 보전을 위해 하드웨어단에서 원자성을 보장할 수 있는 연산을 만든다.

### prevent interrupt
critical section에서는 interrupt가 발생할수 없게한다.
하지만, single core에서만 해결이가능하다.

### Non-preemptive kernel
비 선점 방식의 경우 이러한 문제가 발생하지 않는다. 하지만 preemptive방식에 비해 성능이 떨어진다.

### Mutex, Semaphore
상호 배제. critical section을 보호하는 작업. lock을 사용한다.
Mutex lock: 1개의 자원을 가진 프로세스간에 동기화를 할때 사용
lock은 boolean값으로 이루어짐.

Semaphore: n개의 인스턴스 자원을 공유하는 프로세스간에 동기화를 할 때 사용(n이 1이면 mutext와 유사하다.)
integer로 이루어져있는 형태.
wait() -> 감소, signal() -> 증가로 이루어져있음.
n값을 0으로 초기화 한 후 signal 하는 방식으로 실행 순서를 조절할수도 있음
ex. S1다음 S2실행
```C++
  S1;
  sgnal(synch); // S1이 끝나야 wait 이후의 코드가 실행 가능
```
```C++
  wait(synch);
  S2;
```

busy waiting: 쓸모없이 while문안에서 계속 돌아가고있음.(spin lock)
-> 쓸모없는 cpu연산이 비효율 발생(cpu가 여러개일 경우에는 괜찮다. context switching이 일어나지 않아 오히려 좋다.)

waiting queue: signal() 함수를 통해 signal이 올때까지 waiting queue에 들어가있어 spin lock을 막을 수 있음

**lock을 걸지 않는 해결 방법**
한 번에 하나의 쓰레드만 접근 가능하도록 처리하면 된다.
mutex, semaphore같은 lock을 걸면 잘못 설계했을 때 데드락이 생길 가능성이 높다.
1. Serial queue에 sync로 넣어서 thread safe를 보장한다.

2. concurrent queue와 dispatch barrier 사용
여러개의 스레드 중에서 barrier block의 실행을 위한 하나의 스레드만 제외하고 모든 스레드 사용을 막는 것.
read 작업의 경우에는 일반적인 task로 넣고 write 작업을 barrier task로 넣는 방식으로 dispatch barrier를 응용할 수 있다.
순서를 보장하지는 않는다.

## 교착상태(dead lock)
프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상황
한 process가 여러 자원을 요청할 때 발생한다.

Dead Lock의 조건은 4가지 이다.(모두 만족해야만 deadlock)
- 상호배제: 모든것을 공유하지 않는 배타적 자원을 사용한다.
해결법: 상호 배제를 안하면 교착상태가 일어나지 않는다.
- 점유 및 대기: 이미 점유중이면서 요청을 한다.
해결법: 한 프로세스에 수행되기 전에 모든 자원을 할당시키고 나서 점유하지 않을때 다른 프로세스가 자원을 요구하도록 한다.
기아상태, 무한 대기등의 문제를 유발시킨다.
- 비선점: 자원 강탈이 허용되지 않는다.
해결법: 선점 가능하도록 프로토콜을 만들어 준다.
- 환영대기: circular wait 허용
해결법: 지원 유형에 따라 순서를 매긴다.

해결

**배고픈 철학자 문제**
해결방법
1. 한번에 최대 n-1명의 철학자만이 앉도록 한다.
2. 양쪽이 모두 사용 가능할때만 젓가락을 잡도록 한다.
3. 홀수는 왼쪽, 짝수는 오른쪽을 먼저 잡도록 한다.

## 우선순위의 뒤바뀜
우선순위가 낮은 task가 우선순위가 높은 task의 자원을 가지고 있어 우선순위가 뒤바뀌어 실행되는 현상
우선순위가 낮은 task가 자원을 가지고 있을 경우 우선순위를 높여 빠르게 작업이 끝나도록 만들어 해결.