# 운영체제의 주요 작업
1. 프로세스 관리
2. 메인 메모리 관리
3. 파일 관리
4. 보조 기억장치(HDD, SSD)관리
5. 입출력 장치 관리
6. System Call

## Kernel
운영체제의 핵심 부분으로, 하드웨어 자원을 직접 관리한다.
하드웨어와 프로세스의 보안을 책임지고, 하드웨어적인 요소를 추상화 하여 하드웨어 종속적인 구조를 막아준다.

## 쉘
커널과 사용자 사이에 존재하며, 사용자의 요청을 해석해 커널에 전달한다.
커널에서 요청이 완료되면 응답을 쉘을 통해 사용자에게 전달한다.

## 부팅
전원이 켜지면 먼저 ROM에서 POST와 부트 로더를 실행한다.
POST: 현재 컴퓨터의 상태를 확인한다.
부트 로더: 보조 기억장치에 있는 운영체제를 RAM에 적재시킨다.

**init 프로세스**
운영체제가 RAM에 처음으로 적재되면 최초의 프로세스를 생성한다.
최초의 프로세스가 다른 프로세스를 생성(fork)한다.

**ROM vs RAM**
ROM: 비휘발성 메모리, 읽기만 가능
RAM: 휘발성 메모리, 읽기 쓰기 모두 가능

## 이중 모드
사용자가 모든 자원에 접근이 가능하면 주요 자원(메모리)에 접근해 필수적인 데이터를 망칠 수 있다.
따라서, 이중 모드(사용자 모드, 커널 모드)를 사용해 일반 사용자는 주요 자원에 직접적으로 접근하지 못하도록 해야한다.

- 커널 모드
하드웨어적인 자원에 접근 가능
- 사용자 모드
하드웨어적인 자원에 접근이 불가능
하드웨어적인 자원 접근을 위해서 System Call을 사용한다.

## System Call
- 사용자 모드에서 커널 기능을 사용할 수 있게 해준다.
- 시스템 콜 시 사용자 모드에서 커널 모드로 변경된다.
- 시스템 콜 작업이 완료되면 다시 사용자 모드로 돌아간다.

## 프로세스 큐
CPU는 프로세스 큐를 사용하여 다음에 실행시킬 프로세스를 선택한다.
프로세스 큐에는 순서를 할당받은 프로세스들이 저장된다.
프로세스 큐에는 프로세스의 정보를 표현하는 PCB가 저장된다.
**프로세스 큐의 종류**
- Job Queue
보조 기억장치에 저장된 프로그램 중 메모리 적재를 기다리는 프로그램들을 저장
Long-term Scheduler가 적재할 프로그램의 순서를 정해준다.
Long-term Scheduler는 작업 시간이 가장 오래 걸린다.
- Ready Queue
CPU 할당을 받기 위해서 대기하는 프로세스들을 저장한다.
Short-term Scheuler가 CPU 할당을 받을 프로세스의 순서를 정해준다.
Short-term Scheuler는 작업 시간이 가장 짧다.
- Device Queue
I/O 작업을 위해서 개별 I/O 장치의 할당을 대기하는 프로세스들을 저장한다.

### Medium-term Scheduler(Swapper)
Swapping을 위해서 Swap in과 Swap out을 할 프로세스를 선택한다.

**Swapping**
메모리에 적재된 프로세스중 오랫동안 사용하지 않은 프로세스를 하드디스크로 옮기고 필요시 다시 메모리로 적재하는 것
Swapping을 할 때에는 프로세스의 현재 상태를 담은 프로세스 이미지를 사용한다.
Swapping을 할 때에는 하드디스크 일부를 분리하여 프로세스 이미지를 저장하는데, Backing Store, Swaping Device라고 부른다.
Swap out된 프로세스 이미지를 다시 Swap in 할 경우 새로운 메모리 공간을 가질 수 있다. 하지만 MMU가 있기에 실행에 문제가 없다.
하드디스크에 데이터를 R/W하는 작업이므로 오버헤드가 크다.

### 인터럽트
CPU가 프로세스를 실행중일 때 외부로부터 예외 상황이 발생하여 CPU에게 알려주는 것을 의미한다.
**인터럽트 종류**
I/O
CPU 사용시간 만료
자식 프로세스 만들기(fork)
etc

# 프로그램 메모리 할당 과정
프로그램을 적재할 메모리의 주소는 OS가 관리한다.
다중 프로그래밍에서는 다양한 프로그램이 적재 및 해제되기 때문에 고정된 메모리 주소를 사용할 수 있다.
MMU를 이용해 할당할 프로그램의 메모리 주소를 결정한다.

## MMU
CPU가 메모리에 접근하는 것을 관리하는 하드웨어 부품
CPU는 가상 메모리 주소를 사용하므로 실제 메모리 주소로 변환해줄 필요가 있음
MMU는 가상 메모리 주소를 실제 메모리 주소로 변환해야한다.
MMU는 런타임에 논리 주소를 물리주소로 변환하기 때문에 CPU는 문제없이 논리 주소를 사용할 수 있따.
**MMU 구성**
Relocation Register: 프로세스들의 실제 시작 메모리 주소 정보를 가지고 있어, 프로세스의 시작 주소를 제공해준다.
Base&Limit Register: CPU에서 사용하는 주소가 Base와 Limit 범위를 벗어나는 메모리 주소를 접근할 경우 인터럽트가 발생한다.

## 메모리 적재
동적 적재: 프로그램 실행에 필요한 필수적인 부분만 우선 적재하고, 필요시 추가적으로 메모리에 적재하는 방법
정적 적재: 프로그램의 모든 부분을 실행 시 메모리에 적재하는 방법

## 동적 연결
동일한 라이브러리를 사용하는 여러개의 프로그램은 일반적으로 메모리에 중복되어 라이브러리가 적재된다.
공통으로 사용되는 라이브러리를 메모리에 하나만 올려 공유하는 방법이 동적 연결이다.
동적 연결은 링크 과정이 프로그램 메모리에 적재된 이후 수행된다.
Linux에서는 공유 라이브러리, Windows에서는 동적 연결 라이브러리fkrh qnfmsek.

## 정적 연결
공유할 수 있는 라이브러리를 프로그램 별로 메모리에 중복해서 적재하는 방법
같은 라이브러리가 메모리에 중복되어 잇기 때문에 메모리 낭비가 생긴다.
실행 파일이 생성되기 전에 링크 단계에서 필요한 라이브러리를 모두 연결한다.

## 단편화
프로세스가 자주 할당/해제되면서 여러개의 크기가 다양한 hole이 생긴다.
hole들이 불연속적으로 생성되어있는 상태를 단편화라고 한다.

### 외부 단편화
적재하려는 프로세스의 메모리 크기가 남아있는 hole보다 커서 적재할 수 없는 상태

## 메모리 할당 기법
1. 최초 적합
hole중에 적재가 가능한 첫번째 hole에 적재
가장 빠른 속도
최적 적합과 비슷한 이용률을 가진다.
2. 최적 적합
hole중에 프로세스 크기와 차이가 가장 적은 hole에 적재한다.
외부 단편화로 인해 전체 메모리의 1/3정도를 낭비한다.
3. 최악 적합
hole들중에서 프로세스 크기와 차이가 가장 큰 hole에 적재
4. 압축
흩어져있는 hole들을 하나로 합치는 방법. 오버헤드가 생기는 단점이 있따.

## 페이징
프로세스를 일정한 크기의 페이지로 나누어 메모리에 적재하는 방법
메모리 상에 같은 프로세스가 흩어져서 존재할 수 있는데, 페이지 테이블을 이용해 CPU가 연속적인 메모리 공간이라고 생각하게 만든다.
- 페이지 보호 및 공유
페이지별로 비트를 두어 r/w/x/ 작업을 제한할 수 있다.
같은 프로세스는 같은 code영역을 사용하기에 code 영역을 프로세스끼리 공유하여 메모리를 효율적으로 사용할 수 있다.
단, code는 변하지 않는 프로그램이어야 한다.
- 페이지 크기에 따른 성능
크기가 작을수록 내부 단편화가 줄어든다.(프로세스의 크기가 페이지의 배수가 아니어서 남는 공간)
페이지가 클수록 필요한 페이지가 프레임에 할당될 확률이 높아 page fault가 줄어든다.
페이지가 클수록 페이지 개수가 줄어 페이지 테이블의 크기도 줄어든다.
페이지가 작을수록 불필요한 데이터가 줄기 때문에 메모리 해상도(해당 메모리에 필요한 데이터가 있을 확률)는 증가한다.

### 페이지 vs 프레임
페이지: 프로세스를 일정한 크기로 나눈 조각
프레임: 실제 메모리를 일정한 크기로 나눈 조각, 페이지 크기오 ㅏ동일

### 페이지 테이블
CPU가 사용하는 논리 주소를 이용해 실질적인 물리 주소로 변환해준다.
물리적인 메모리 상에서 흩어져 있는 페이지를 CPU가 느끼기에는 연속적인 메모리 공간에 적재되어 있는것 처럼 만들어준다.
- 주소 변환
논리 주소: CPU가 사용한다. 페이지 번호와 변위로 구성되어 있다. 총 m비트로 구성되어 있을 때 하위 n 비트는 offset 또는 변위라고 한다. 상위 m-n비트는 페이지 번호이다.
물리 주소: 논리 주소의 페이지 번호와 변위를 사용해 구한다. 페이지 테이블에서 페이지 번호와 매칭되는 프레임 번호를 찾고 뒤에 변위를 붙여 물리 주소를 계산한다.

**생성**
CPU의 레지스터를 사용: 주소 변환 속도가 빠르지만 크기가 작아 한정적
메모리 사용: 레지스터보다는 느리지만 테이블의 크기를 크게 만들 쑤 있음. 메모리를 사용하면 주소 변환을 위해 2번 접근해야함(페이지 테이블 접근, 프레임 접근)
TLB사용:
TLB는 페이지 테이블을 위한 캐시이다. CPU와 메모리 사이에 존재한다.
주소 변환 속도는 메모리보다 빠르고, 크기는 레지스터보다 크다.
실제 페이지는 메모리에 있고, TLB는 캐시 용도로 일부 페이지만 저장한다.
TLB에 유효한 페이지가 있으면 TLB를 읽는 시간 + 메모리를 읽는 시간만 필요하다.
TLB에 유효한 페이지가 없으면 TLB에 페이지를 쓰고 읽어야 하므로 메모리를 2번 읽어야한다.

## 세그멘테이션
프로세스를 일정하지 않은 크기의 세그먼트로 나누어 메모리에 적재하는 방법
세그먼트 테이블을 사용해 논리적인 주소를 물리적인 주소로 변환한다.
세그먼트 테이블 보호 & 공유:
세그먼트를 논리적으로 나누기 때문에 r/w/x 작업을 제한하기 좋다.
code 영역만 세그먼트로 나눌수 있기 때문에 공유에서도 효율적이다.
단점:
크기가 다양하기 때문에 hole이 다양한 크기로 생성되 외부 단편화가 생긴다.
보완:
세그먼트를 페이징 기법으로 사용할 수 있다.
하지만 메모리 주소 변환을 두번해야한다.(논리 -> 세그먼트 테이블 -> 페이지 테이블 -> 물리 주소)

### 가상 메모리
주 기억장치의 공간 부족으로 보조 기억장치를 이용해 메모리 공간을 가상으로 늘려주는 기법
물리 메모리보다 큰 프로세스를 실행시키기 위해 사용한다.

### 요구 페이징
프로세스에서 현재 실행에 필요한 부분만(페이지 or 세그먼트) 적재시켜 프로세스를 실행한다.
valid bit를 사용해 페이지 테이블에 페이지가 존재하는지 확인할 수 있다.
valid bit가 0이면 페이지가 존재하지 않으므로 CPU에 인터럽트 신호를 보내 메모리에 원하는 페이지를 적재시킨다.
요구 페이지 종류:
- pure demanding paging
프로세스가 최초로 실행될 때 어떤 페이지가 필요한지 모르기에 아무 페이지도 올리지 않는다.
따라서 page fault가 발생하고 페이지를 탐색해 프레임에 할당한다.
메모리를 효율적으로 사용할 수 있지만, 시작부터 페이지 부재가 발생해 속도가 느리다.
- preparing
프로세스가 최초로 실행될 때 필요한 것으로 보이는 페이지를 먼저 프레임에 할당한다.
page fault가 발생하지 않아 속도는 빠르지만, 프레임에 할당된 페이지를 사용하지 않으면 메모리를 낭비할 수 있다.

## page fault
CPU가 접근하려는 페이지가 메모리에 없는 상태이다.(페이지 테이블에서 valid bit가 0인경우)
페이지 부재 처리과정
- 페이지가 메모리에 적재되어 있는지 확인
- 없을 경우 ISR로 점프, ISR에서 Backing sotre를 탐색하여 페이지를 찾는 작업 수행
- 탐색한 페이지를 프레임에 할당
- 인터럽트 발생 이전의 명령어를 수행한다.

### 지역성의 원리
메모리 접근에는 시간적, 공간적인 지역성을 가지고 있다.
따라서 페이지 부재가 일어날 확률이 매우 낮다.
시간 지역성: CPU는 시간이 지나도 동일한 메모리 공간을 접근할 확률이 높다.(반복문)
공간 지역성: CPU가 메모리를 읽을 때, 근처에 있는 메모리 공간에 접근할 확률이 높다.(절차적인 코드 실행)

### 페이지 교체
메모리의 프레임이 모두 할당되어 있다면, 새로운 페이지를 할당하기 위해 기존의 페이지를 Backing Store로 보내고, 새로운 페이지를 메모리에 할당한다.
- 페이지 참조열
페이지 교체 알고리즘을 위해서는 이진수의 주소가 아닌 페이지 번호가 필요하다.
연속적으로 같은 페이지를 사용할 때에는 하나의 페이지만 남겨도 된다.
- 페이지 교체 알고리즘
FIFO: 가장 먼저 들어온 페이지를 교체한다.
OPT: 가장 오랫동안 사용하지 않을 페이지를 교체한다.(미래를 예상하는것이 현실적으로 불가능)
LRU: 가장 오랫동안 사용하지 않은 페이지를 교체한다.

페이지 교체시 다른 프로세스에서 page frame을 뺏어오거나(global replacement)
자신에게 할당된 frame 내에서만 replace(local replacement)할수 있다.
global replacement 할 경우 thrashing이 발생한다.

**쓰레싱**
메모리에 올라와 있는 프로그램이 늘어날 수록 CPU 이용량은 올라가지만
메모리에 프로그램이 너무 많이 올라가면 page frame 수가 적어 page fault가 자주일어나 CPU 효율이 낮아지는 현상

방지법
1. working-set model
working-set: 지역성에 기반하여 프로세스가 일정시간동안 원활하게 수행되기 위해 한번에 메모리에 올라와있어야하는 page들의 집합
프로세스의 working-set 전체가 메모리에 올라와 있어야 프로세스가 실행되고 그러지 않을 경우 모든 frame을 반환한 다.
2. 프로세스당 적잘한 수의 프레임을 할당
- 동일할당
모든 프로세스에게 동일한 양의 프레임을 할당
프로세스 크기에 따라 비효율적
- 비례 할당
프로세스의 크기에 비례해 할당. 모든 프레임을 사용하지 않을 수 있어 비효율적일 수 있다.