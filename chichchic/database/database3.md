# NoSql
## NoSql 데이터 모델링 기법
composite key -> 하나 이상의 필드를 ':'로 구분지어 사용한다.
하나 이상의 KV(key value) store의 경우 order by와 같은 sorting 기능이나 grouping을 구현 가능하다.
key를 기준으로 N개의 서버에 나눠서 저장된다.

### Inverted Search Index
value를 key key를 Value로 사용하는 패턴
검색어 - URL에서 많이 사용된다.
수집시에는 URL: key, 검색어: value,
검색시에는 검색어: key, URL: value.

### 계층 데이터 구조 모델링 패턴
NoSql도 기본적으로 raw column을 가지고 있는다. (따라서 계층형 구조를 저장하기는 어렵다.)
1. Tree Aggregation
트리 자체를 Value에 저장하는 방식
JSON or XML등을 이용한다.
변경이 적고 트리가 작을 때 적합하다.
2. Materialized Path
Key를 Root에서부터 경로로 설정하는 방식
ex) A/, A/B, A/D, A/B/S ...

### 데이터 모델링 예시
- 도메인 모델 파악
개체간 관계 분석
ERD 그려서 도식화
- 쿼리 결과 디자인
도메인 기반 쿼리 수행 결과값을 지정한다.
출력 형식 기반 필요한 쿼리를 정의한다.
출력 데이터 기반 테이블을 추출한다.
- 패턴을 활용한 데이터 모델링
sorting, grouping, join이 제공되지 않으므로
Get, Put으로 데이터 처리가 가능하도록 모델 재정의
- 기능 최적화
첨부파일: 포스팅에 의존적, 개수가 적어 하나의 필드에 모으는게 유리하다.
분류에 따른 포스팅 출력: 포스팅에 분류 필드를 넣고 where문으로 select가 가능해야한다.
- NoSql 선정 및 테스트
모델링 한 데이터 구조를 효과적으로 실행 가능한지 검토
특징 분석, 부하 테스트
안정성, 확장성 테스트
경우에 따라, 여러개의 NoSql을 복합해서 사용하거나 RDBMS와 함께 사용한다.(테스트의 궁국적인 목적은 여기에 있다.)
- 선정된 NoSql에 최적화된 하드웨어 디자인
해당 NoSql에 맞는 App 설계
구동시킬 하드웨어 디자인
데이터 모델과 내부 아키텍쳐를 제대로 파악하고 그에 맞는 NoSql을 선정한다.

결론: 모델링이 80%이상을 차지한다. 선정한 NoSql과 App특성에 맞는 데이터 모델링을 해야한다.

## mongo DB
mongo DB는 수평적 확장을 한다.
한대 이상의 서버로 구성하는것이 일반적이다.
mongo DB는 사용 가능량 대비 메모리에 성능이 좌우된다.(독립된 서버에서 실행하는것을 권장한다.)
기본적으로 mongoDB는 mongod 단위로 실행한다.
데이터 손상시 복구가 불가능해 3개의 replica 단위로 구성하여 복제한다.
mongos 서버를 통해 마치 한대의 DB서버처럼 사용이 가능하다.(샤딩 가능, 같은 테이블 스키마를 가진 데이터를 다수의 DB에 분산 저장하는 기법)
ex) 3대의 서버를 가지고 복제 set, 위와 같은 형태로 3개의 shard를 구성. mongos router로 구성(이 또한 여러 서버로 분산하여 load balancer로 분산 가능하다.)
필요하다면 다른곳에 data center 복제 set을 구성하여 운영도 가능하다.

총 4개의 운영체제를 지원한다.(윈도우, 리눅스, unix sedaris, Mac OS X)
대부분은 리눅스를 사용한다.
MongoDB 철학: 메모리 관리는 OS에게. 상대적으로 메모리 관리가 뛰어난 unix 베이스의 운영체제를 이용하는것이 좋다.

key-value와는 다르게 여러 용도로 사용이 가능하다.
스키마를 고정하지 않는 형태이다.(데이터를 구조화해 JSON 형태로 저장한다.)
join이 불가능해서 join이 필요없게 설계해야한다.(데이터 중복이 생겨난다.)

메모리 맵 형태의 파일엔진 DB이기에 메모리 의존적이다.
메모리를 넘어서면 급격하게 성능이 떨어진다.
쌓아두고 삭제가 없는 경우가 적합하다.(로그 데이터, 이벤트 참여내역, 세션 등)
transaction이 필요한 금융, 결제, 회원 정보등에는 부적합하다.(RDBMS를 사용)

**도큐먼트 데이터 모델**
속성의 이름과 값으로 이루어진 쌍의 집홥.
속성은 문자열이나 숫자, 날짜 가능
배열 또는 다른 도큐먼트를 지정할 수 있다.
하나의 document에 필요 정보 모두를 담아야한다.
one query로 해결되게 collection model을 설계해야한다.
join이 불가능하므로 미리 embading 하는것이 좋다.

### 장점
schema-less 구조
다양한 형태의 data를 저장할 수 잇다.
데이터 모델의 유연한 변화가 가능하다.(필드 확장이 용이)
read/write 성능이 뛰어나다.
sacle out 구조. 많은 데이터 저장이 가능하다. 장비 확장이 간단하다.
json 구조: 데이터 직관적 이해가 가능하다.
사용방법이 쉽고 개발이 편리하다.

### 단점
데이터 업데이트 장애 발생시 데이터 손상 가능성이 있다.
많은 인덱스를 사용할 경우 충분한 메모리가 필요하다.
데이터 공간 소모가 RDBMS에 비해 많다.(비 효율적인 key 중복으로 인해)
복잡한 join 사용시 성능 제약이 따른다.
transaction 지원이 RDBMS 대비 미약하다.
제공되는 MapReduce(대용량 data 처리를 위한 분산 프로그래밍 모델) 작업이 Hadoop(대용량 자료 처리 프레임워크)에 비해 성능이 떨어진다.

**mongoDB는 빅데이터 처리에 특화**
Memory Mapped(write시 OS의 가상 메모리에 data를 넣은 후 비동기로 디스크에 기록한다.)
방대한 데이터를 빠르게 처리할 수 있다.
OS의 메모리를 사용하기에 메모리가 차면 하드디스크로 처리하여 속도가 떨어진다.
하드웨어적 측면에서 투자가 필요하다.

### 불안정성
(이유: 메모리 DB의 특징을 가지고 있기 때문)
데이터 양이 많을 경우 일부 데이터 손실 가능성이 있다.
샤딩의 비 정상적인 동작 가능성이 있다.
레플리카 프로세스의 비정상 동작 가능성이 있다.

### mongoDB VS RDBMS
동일 데이터를 두고 CRUD할 경우 mongo가 더 빠르다.
TODO: node가 뭐지?
mongo의 경우 single node와 multi node간 성능 차이가 거의 없다.
mongo에서 multi node에 insert 연상 중 연산 실패가 일어날 수 있다.
분산을 목적으로 할 경우 비용과 속도면에서 mongo가 유리하다.

### 인덱스
다수의 인덱스를 설정할 수 있다.
복합 인덱스를 지원한다.
빠른 검색을 지원한다.
document에 저장된 데이터와 중복 저장 문제가 존재한다.
메모리가 부족할 경우 검색 속도 저하 문제가 발생한다.

**인덱스란**
DB에서 테이블에 대한 동작의 속도를 높여주는 자료구조를 뜻한다.
테이블 내의 1개의 컬럼 또는 여러개의 컬럼을 이용해 생성될 수 있다.
고속의 검색 동장 뿐 아니라 레코드 접근과 관련, 효율적인 순서 매김 동작에 대한 기초를 제공한다.
인덱스는 key필드만 가지고 있고 다른 세부 항목들은 가지고 있지 않다.
고정된 스키마는 없다.
한 query당 하나의 index만 유효하다.
무한히 추가하는것은 불가능하다.(유지비 소요)
읽기 위주의 APP에서 유용하다.
쓰기가 많다면 포기하거나 index를 위한 collection을 운용해야한다.
모든 data를 메모리에 mapping한다.
-> page라고 불리는 4kb정도의 단위로 운영체제에 의해 RAM에 적재한다.
-> 따라서 모든 데이터 수용이 가능할 경우 access 횟수를 최소화 해준다.
-> 하지만, 그렇지 못할 경우 page fault 발생으로 인해 latency가 발생한다.
모든 데이터를 디스크에서 access 하는것은 thrashing(메모리에 접근하게 될 때 page fault 비율이 높은 것)을 유발시켜 굉장히 비효율적이다.

종류: B-tree Index(주로 사용, mongoDB에서도 채택), Bitmap Index, IOT index, Clustered Index.

### 샤딩
소프트웨어적으로 DB를 분산시켜 처리하는 구조
샤딩 방식: 테이블을 테이블 단위로 분리, 테이블 자체를 분할
DB의 전통적인 분할 3계층 구조: 응용 - 중개(중간을 거쳐야지만 데이터 접근이 가능하다. 추상화 된 1개의 DB가 존재하듯 운용한다.) - 데이터

### mapreduce
대용량의 데이터를 안전하고 빠르게 처리하기 위한 방법.
데이터를 분산하여 연산하고 다시 합치는 기술.
맵과 리듀스 단계로 나누어 처리, 사용자가 임의로 코딩할 수 있다.
입출력 데이터는 KV형태이다.
한대 이상의 하드웨어를 활요하는 분산 프로그래밍 모델: 분산을 통해 분할된 조각으로 처리 후 다시 모아 짧은 시간안에 연산이 가능하다.
대용량 파일에 대한 로그분석, 인덱스구축에 활용된다.
일괄 처리 방식으로 전체 data set을 분석할 필요가 있을 때 적합하다.