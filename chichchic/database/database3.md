# NoSql
빅데이터의 등장으로 기존 RDBMS의 한계를 극복하고자 만들어진 새로운 형태의 데이터 저장기술
RDBMS와 다른 구조의 데이터 저장구조를 통칭한다.

## 특징
데이터간의 관계를 정의하지 않는다.
페타 바이트급의 대용량 데이터를 저장할 수 있다.
일반적인 서버 수십대를 연결해 데이터를 저장 및 처리한다.
(분산 저장, 상호 복제로 서버 장애에도 데이터 유실 및 서비스 중지가 없다.)
TABLE의 스키마가 유동적이다.
ID로 사용하는 KEY 부분만 타입이 동일하고 나머지 컬럼은 타입과 이름이 제한되지 않는다.
CAP이론을 따른다.

**CAP이론이란**
분산 컴퓨팅 환경은
일관성(C, 모든 노드들을 같은 시간에 동일한 항목에 대해 같은 내용을 사용자에게 보여준다.)
가용성(A, 모든 사용자들이 읽기 및 쓰기가 가능해야하며 몇몇 노드의 장애 시에도 다른 노드에 영향을 주어서는 안된다.)
부분결함 용인(P, 메세지 전달이 실패하거나 시스템 일부가 망가져도 시스템이 계속 동작할 수 있어야한다.)
이라는 3가지 특징이 존재하고 이중 2가지만 만족할 수 있다.
RDBMS: CA
NoSql: CP or AP

## 종류
1. key/value store(redis): unique한 key 하나에 value를 가진 형태
2. ordered key/value store(cassandra): 1key에 column으로 여러 정보를 저장할 수 있다.
3. document key/value store(mongo DB): 복잡한 계층 구조 표현이 가능하다.

## 장점
App 특징적 접근 패턴에 따라 모델링이 가능하다.
내가 가진 질문이 무엇인가에 집중할 수 있다.(요구사항에 집중)
필요한 쿼리와 성능을 정의한 후에 모델을 정의한다.
특정 용도에 특화되어있다.
독립적 설계로 분산이 용이하다.
캐시가 필요할때, 고속으로 처리할 때, 모든 data를 저장할 때 유리하다.

## 단점
NoSql 솔루션의 특징을 알아야한다.
join이 불가능하다.
버그가 많다.
운영 노하우(지금 까지 경험적으로 쌓인 정보)가 적다
솔루션들이 너무 많다.

## NoSql 데이터 모델링 기법
composite key -> 하나 이상의 필드를 ':'로 구분지어 사용한다.
하나 이상의 KV(key value) store의 경우 order by와 같은 sorting 기능이나 grouping을 구현 가능하다.
key를 기준으로 N개의 서버에 나눠서 저장된다.

### 모델링 특징
관계형 DB보다 더 깊은 데이터 구조 및 알고리즘에 대한 이해가 필요하다.
NoSql쿼리가 실제 몇개의 물리 노드에 걸쳐 수행되는지 이해가 있어야 좋은 쿼리 디자인이 가능하다.
DB와 APP뿐만 아니라 인프라(네트워크, 디스크)에 대한 디자인도 함께 해야한다.
보안에 취약할 수 있어 체계를 마련해야한다.

### 모델링 개념
비 정규화를 통해 데이터 중복을 허용한다.
쿼리 프로세싱을 단순화한다.
사용자의 데이터를 특정 데이터 모델에 맞춘다.
비정규화롤 인한 trade off 발생
쿼리당 I/O vs 전체 data size(빅데이터에서는 관대함)
쿼리 수행 복잡도 vs 전체 data size(빅데이터에서는 관대함)
I/O 횟수가 줄어 성능이 향상되고 쿼리 친화적 구조로 묶어둘 수 있다.
데이터 모델링 이후 정규화를 할 경우 쿼리 프로세스의 복잡도가 올라간다.
시스템과 데이터가 큰 분산 호나경에서 복잡도가 상승한다.
중복 저장으로인해 data size가 증가한다.
스키마를 구성한 이후에 스키마 변경이 용이하기에 큰 위험성이 없다.(1: n 연산을 줄여 join연산을 줄여 대용량 데이터 지원이 가능해진다.)
복잡하고 다양한 비지니스 요소를 유연하게 담을 수 있다. 따라서 예측하기 어려운 구조의 파일 포맷도 지원이 가능하다.

**비정규화, aggrigation을 수행할 때 join대상 데이터에 문제가 생기는 경우**
1. join 대상이 n:m관계
2. join 대상의 데이터를 수시로 변경할 때(수시로 변경되는 data는 RDBMS로 분산저장 해 관리하거나 APP에서 join하도록 하는것이 좋다.)

### Inverted Search Index
value를 key key를 Value로 사용하는 패턴
검색어 - URL에서 많이 사용된다.
수집시에는 URL: key, 검색어: value,
검색시에는 검색어: key, URL: value.

### 계층 데이터 구조 모델링 패턴
NoSql도 기본적으로 raw column을 가지고 있는다. (따라서 계층형 구조를 저장하기는 어렵다.)
1. Tree Aggregation
트리 자체를 Value에 저장하는 방식
JSON or XML등을 이용한다.
변경이 적고 트리가 작을 때 적합하다.
2. Materialized Path
Key를 Root에서부터 경로로 설정하는 방식
ex) A/, A/B, A/D, A/B/S ...

### 데이터 모델링 예시
- 도메인 모델 파악
개체간 관계 분석
ERD 그려서 도식화
- 쿼리 결과 디자인
도메인 기반 쿼리 수행 결과값을 지정한다.
출력 형식 기반 필요한 쿼리를 정의한다.
출력 데이터 기반 테이블을 추출한다.
- 패턴을 활용한 데이터 모델링
sorting, grouping, join이 제공되지 않으므로
Get, Put으로 데이터 처리가 가능하도록 모델 재정의
- 기능 최적화
첨부파일: 포스팅에 의존적, 개수가 적어 하나의 필드에 모으는게 유리하다.
분류에 따른 포스팅 출력: 포스팅에 분류 필드를 넣고 where문으로 select가 가능해야한다.
- NoSql 선정 및 테스트
모델링 한 데이터 구조를 효과적으로 실행 가능한지 검토
특징 분석, 부하 테스트
안정성, 확장성 테스트
경우에 따라, 여러개의 NoSql을 복합해서 사용하거나 RDBMS와 함께 사용한다.(테스트의 궁국적인 목적은 여기에 있다.)
- 선정된 NoSql에 최적화된 하드웨어 디자인
해당 NoSql에 맞는 App 설계
구동시킬 하드웨어 디자인
데이터 모델과 내부 아키텍쳐를 제대로 파악하고 그에 맞는 NoSql을 선정한다.

결론: 모델링이 80%이상을 차지한다. 선정한 NoSql과 App특성에 맞는 데이터 모델링을 해야한다.

## mongo DB
mongo DB는 수평적 확장을 한다.
한대 이상의 서버로 구성하는것이 일반적이다.
mongo DB는 사용 가능량 대비 메모리에 성능이 좌우된다.(독립된 서버에서 실행하는것을 권장한다.)
기본적으로 mongoDB는 mongod 단위로 실행한다.
데이터 손상시 복구가 불가능해 3개의 replica 단위로 구성하여 복제한다.
mongos 서버를 통해 마치 한대의 DB서버처럼 사용이 가능하다.(샤딩 가능, 같은 테이블 스키마를 가진 데이터를 다수의 DB에 분산 저장하는 기법)
ex) 3대의 서버를 가지고 복제 set, 위와 같은 형태로 3개의 shard를 구성. mongos router로 구성(이 또한 여러 서버로 분산하여 load balancer로 분산 가능하다.)
필요하다면 다른곳에 data center 복제 set을 구성하여 운영도 가능하다.

총 4개의 운영체제를 지원한다.(윈도우, 리눅스, unix sedaris, Mac OS X)
대부분은 리눅스를 사용한다.
MongoDB 철학: 메모리 관리는 OS에게. 상대적으로 메모리 관리가 뛰어난 unix 베이스의 운영체제를 이용하는것이 좋다.

key-value와는 다르게 여러 용도로 사용이 가능하다.
스키마를 고정하지 않는 형태이다.(데이터를 구조화해 JSON 형태로 저장한다.)
join이 불가능해서 join이 필요없게 설계해야한다.(데이터 중복이 생겨난다.)

메모리 맵 형태의 파일엔진 DB이기에 메모리 의존적이다.
메모리를 넘어서면 급격하게 성능이 떨어진다.
쌓아두고 삭제가 없는 경우가 적합하다.(로그 데이터, 이벤트 참여내역, 세션 등)
transaction이 필요한 금융, 결제, 회원 정보등에는 부적합하다.(RDBMS를 사용)

**도큐먼트 데이터 모델**
속성의 이름과 값으로 이루어진 쌍의 집홥.
속성은 문자열이나 숫자, 날짜 가능
배열 또는 다른 도큐먼트를 지정할 수 있다.
하나의 document에 필요 정보 모두를 담아야한다.
one query로 해결되게 collection model을 설계해야한다.
join이 불가능하므로 미리 embading 하는것이 좋다.

### 장점
schema-less 구조
다양한 형태의 data를 저장할 수 잇다.
데이터 모델의 유연한 변화가 가능하다.(필드 확장이 용이)
read/write 성능이 뛰어나다.
sacle out 구조. 많은 데이터 저장이 가능하다. 장비 확장이 간단하다.
json 구조: 데이터 직관적 이해가 가능하다.
사용방법이 쉽고 개발이 편리하다.

### 단점
데이터 업데이트 장애 발생시 데이터 손상 가능성이 있다.
많은 인덱스를 사용할 경우 충분한 메모리가 필요하다.
데이터 공간 소모가 RDBMS에 비해 많다.(비 효율적인 key 중복으로 인해)
복잡한 join 사용시 성능 제약이 따른다.
transaction 지원이 RDBMS 대비 미약하다.
제공되는 MapReduce(대용량 data 처리를 위한 분산 프로그래밍 모델) 작업이 Hadoop(대용량 자료 처리 프레임워크)에 비해 성능이 떨어진다.

**mongoDB는 빅데이터 처리에 특화**
Memory Mapped(write시 OS의 가상 메모리에 data를 넣은 후 비동기로 디스크에 기록한다.)
방대한 데이터를 빠르게 처리할 수 있다.
OS의 메모리를 사용하기에 메모리가 차면 하드디스크로 처리하여 속도가 떨어진다.
하드웨어적 측면에서 투자가 필요하다.

### 불안정성
(이유: 메모리 DB의 특징을 가지고 있기 때문)
데이터 양이 많을 경우 일부 데이터 손실 가능성이 있다.
샤딩의 비 정상적인 동작 가능성이 있다.
레플리카 프로세스의 비정상 동작 가능성이 있다.

### mongoDB VS RDBMS
동일 데이터를 두고 CRUD할 경우 mongo가 더 빠르다.
mongo의 경우 single node와 multi node간 성능 차이가 거의 없다.
mongo에서 multi node에 insert 연상 중 연산 실패가 일어날 수 있다.
분산을 목적으로 할 경우 비용과 속도면에서 mongo가 유리하다.

### 인덱스
다수의 인덱스를 설정할 수 있다.
복합 인덱스를 지원한다.
빠른 검색을 지원한다.(O(1), O(log n)등 O(n)보다 빠르게 검색이 가능하도록 해준다.)
document에 저장된 데이터와 중복 저장 문제가 존재한다.
메모리가 부족할 경우 검색 속도 저하 문제가 발생한다.
search key, pointer로 구성되어있다.

**인덱스란**
DB에서 테이블에 대한 동작의 속도를 높여주는 자료구조를 뜻한다.
테이블 내의 1개의 컬럼 또는 여러개의 컬럼을 이용해 생성될 수 있다.
고속의 검색 동장 뿐 아니라 레코드 접근과 관련, 효율적인 순서 매김 동작에 대한 기초를 제공한다.
인덱스는 key필드만 가지고 있고 다른 세부 항목들은 가지고 있지 않다.
고정된 스키마는 없다.
한 query당 하나의 index만 유효하다.
무한히 추가하는것은 불가능하다.(유지비 소요)
읽기 위주의 APP에서 유용하다.
쓰기가 많다면 포기하거나 index를 위한 collection을 운용해야한다.
모든 data를 메모리에 mapping한다.
-> page라고 불리는 4kb정도의 단위로 운영체제에 의해 RAM에 적재한다.
-> 따라서 모든 데이터 수용이 가능할 경우 access 횟수를 최소화 해준다.
-> 하지만, 그렇지 못할 경우 page fault 발생으로 인해 latency가 발생한다.
모든 데이터를 디스크에서 access 하는것은 thrashing(메모리에 접근하게 될 때 page fault 비율이 높은 것)을 유발시켜 굉장히 비효율적이다.

종류: B-tree Index(주로 사용, mongoDB에서도 채택), Bitmap Index, IOT index, Clustered Index.

### 샤딩
소프트웨어적으로 DB를 분산시켜 처리하는 구조
샤딩 방식: 테이블을 테이블 단위로 분리, 테이블 자체를 분할
DB의 전통적인 분할 3계층 구조: 응용 - 중개(중간을 거쳐야지만 데이터 접근이 가능하다. 추상화 된 1개의 DB가 존재하듯 운용한다.) - 데이터

### mapreduce
대용량의 데이터를 안전하고 빠르게 처리하기 위한 방법.
데이터를 분산하여 연산하고 다시 합치는 기술.
맵과 리듀스 단계로 나누어 처리, 사용자가 임의로 코딩할 수 있다.
입출력 데이터는 KV형태이다.
한대 이상의 하드웨어를 활요하는 분산 프로그래밍 모델: 분산을 통해 분할된 조각으로 처리 후 다시 모아 짧은 시간안에 연산이 가능하다.
대용량 파일에 대한 로그분석, 인덱스구축에 활용된다.
일괄 처리 방식으로 전체 data set을 분석할 필요가 있을 때 적합하다.