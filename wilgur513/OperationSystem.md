# 프로세스
* 메모리에 적재되어 CPU의 할당을 받은 실행 중인 프로그램
* 코드/데이터/힙/스택 영역으로 나누어 메모리에 적재됨
  * 코드 : 프로그램의 명령어 저장
  * 데이터 : 전역 변수, 정적 변수 저장
  * 힙 : 런타임에 동적으로 할당하여 사용
  * 스택 : 지역 변수, 매개 변수, 함수 호출 정보를 저장
* 각 프로세스는 개별적인 코드/데이터/힙/스택 영역을 가짐
* CPU는 한번에 하나의 프로세스만 실행시킴

# 스레드
* 프로세스가 할당받은 자원을 이용하는 실행 단위
* 같은 프로세스 내의 스레드는 코드/힙/데이터는 공유하지만, 개별적인 스택영역을 가지고 있음

# 프로세스 vs 스레드
* 프로세스
  * 개별적인 메모리 공간을 사용하므로, 타 프로세스의 영역에 접근할 수가 없다.
  * 타 프로세스의 자원에 접근하기 위해서는 IPC(Inter-Process Communication)를 사용해야한다.
* 스레드
  * 같은 프로세스 내의 힙/데이터/코드 영역을 공유하므로, 프로세스에 비해 효율적으로 통신이 가능하다.
  * 프로세스에 비해 생성 및 종류 시간과 전환시간(문맥 교환)이 짧다.

# 멀티 프로세스
* 다수의 프로세서를 활용하여 동시에 프로세스를 실행시키는 상태

# 멀티 스레딩
* 하나의 프로세스에 다수의 스레드를 실행시키는 상태
* 스레드는 프로세스에 비해 문맥 교환 시간이 짧고, 스레드 간 통신 방법이 간단하다.
* 스레드 간 공유하는 자원으로 인해 동기화 문제가 발생할 수 있다.

# 동기화
* 한정적인 공유 자원을 동시에 여러 프로세스/스레드가 접근하면 예기치 못한 문제가 발생할 수 있다.
* 동기화는 프로세스/스레드 간의 공유 자원 접근을 관리하여 문제가 발생하지 않도록 하는 기법이다.

# 멀티 스레드 vs 멀티 프로세스
* 멀티 스레드
  * 멀티 스레드는 멀티 프로세스보다 스레드를 사용하기 때문에 메모리 공간을 적게 활용하고, 문맥 교환 시간이 짧다.
  * 하지만, 멀티스레드는 동기화 문제가 발생할 수 있다.
* 멀티 프로세스
  * 하나의 프로세스가 문제가 발생해도 다른 프로세스에게 영향을 끼치지 않는다.
  * 멀티 스레드에 비해 프로세스를 활용하기 때문에 메모리 공간과 CPU 시간을 더 차지한다.

# 멀티 프로그래밍
* 단일 프로세서에서 CPU 작업과 I/O 작업을 병행하는 상태
* I/O 작업으로 인해 CPU가 유휴상태가 되면, CPU 작업이 필요한 다른 프로세스를 실행시킴
* CPU의 이용과 처리량을 증가시킬 수 있음

# PCB(Process Control Block)
* 프로세스 생성시 만들어지며, 프로세스 관리에 필요한 정보를 포함하는 커널의 자료구조
* 일반 사용자가 접근하지 못하는 보호된 메모리 영역에 존재함
* 프로세스에 대한 정보
  * 프로세스 식별자(PID)
  * 프로세스 상태
    * 생성(create), 준비(ready), 실행(running), 대기(waiting), 완료(terminated)
  * PC(Program Counter): 프로세스가 다음에 실행할 명령어의 주소
  * CPU 레지스터 및 일반 레지스터
  * CPU 스케줄링 정보: 우선 순위, 최종 실행시각, CPU 점유시간 등
  * 메모리 관리 정보: 해당 프로세스의 주소 공간 등
  * 프로세스 계정 정보: 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등
  * 입출력 상태 정보: 프로세스에 할당된 입출력장치 목록, 열린 파일 목록 등

# 문맥교환(Context Switch)
* 현재 실행중인 프로세스가 인터럽트에 의해 다음 프로세스가 실행되어야 할 때, 기존 프로세스의 상태(문맥)을 PCB에 저장하고 다음 프로세스의 실행을 위해 다음 상태로 교체하는 작업
* 문맥교환이 발생하면 CPU는 아무런 일을하지 못한다. 따라서, 너무 잦은 문맥교환은 CPU의 처리량을 감소시킨다.

# 인터럽트
* CPU가 프로세스를 실행중일 때, 외부로부터 예외상황이 발생하여 CPU에게 알려주는 것을 의미한다.
* 인터럽트의 종류
  * I/O 요청
  * CPU 사용시간 만료
  * 자식 프로세스를 만들때(fork)
  * 기타 등등


# 커널 스레드
* 추후 추가예정
# 사용자 스레드
* 추후 추가예정

# 병렬성
* 여러 개의 프로세스가 동시에 실행됨
# 동시성
* 여러 개의 프로세스가 시분할하여 순차적으로 실행됨
* 사용자는 여러 개의 프로세스가 한번에 실행되는것처럼 느껴짐

# 임계영역(Critical Section)
* 여러 프로세스가 동시에 접근해서는 안되는 자원에 접근하는 영역(즉, 여러개의 프로세스가 공유자원을 사용하는 영역)
* 임계영역에 접근하는 순서에 따라서 결과가 달라짐
* 임계영역이 만족해야하는 조건
  * 상호배제 : 한 프로세스/스레드가 임계 영역에서 작업 중이면, 타 프로세스/스레드는 접근할 수 없다.
  * 진행 : 임계 영역에서 작업 중인 프로세스/스레드가 없을 때, 동시에 여러 프로세스/스레드가 접근하려하면 어떤 프로세스/스레드를 진행시킬 지 정해야한다.
  * 한정 대기 : 

# 경쟁 상태(Race Condition)
* 여러개의 프로세스가 동일한 임계영역을 가지고, 서로 점유하기 위해 경쟁하는 상태

# 상호배제(Mutual Exclusion)
* 여러개의 프로세스가 임계영역에 동시에 진입하지 않도록 제어하는 매커니즘

# 뮤텍스
* 임계영역에 진입할 수 있는 스레드를 하나로 제한
* 임계영역에 진입하기 위해서는 락을 획득한 다른 스레드가 해제해야지만 진입 가능
* 바이너리 세마포어와 유사한 방식
# 세마포어
* 임계영역에 진입할 수 있는 프로세스를 n개로 제한
* 동기화 대상이 여러개의 프로세스일 때 주로 사용, wait와 signal을 사용해 동기화
  * wait
    * 세마포어 변수를 1감소
    * 세마포어 변수가 0일 때 진입 불가(타 프로세스가 signal을 호출해 자원을 해제해야 진입 가능)
  * signal
    * 세마포어 변수를 1증가
    * 자원을 해제하기 위해서 사용
* 세마포어 변수가 1일 경우(바이너리 세마포어) 뮤텍스처럼 사용 가능 
# 모니터락
* 추후 추가 예정

# 교착상태(Deadlock)
* 프로세스가 이미 점유된 자원을 요청 시, 해당 자원을 점유한 프로세스가 대기큐에 있어 작업이 끝나길 무한정 기다리는 상태
* 교착 상태 4가지 조건
  * 상호배제
  * 환형구조
  * 비선점
  * 점유와 대기
* 교착 상태 해결 방법
  * 추후 추가 예정
